# GenTrade Application Flow Documentation

## 1. Introduction

GenTrade’s application flow centers on a conversation-based interface where users can quickly generate, edit, deploy, and backtest crypto trading strategies. The **FastAPI** backend, orchestrated by `app/main.py`, provides RESTful endpoints and an event-streaming route (`/chat`) that coordinates LLM calls.

Below is an outline of how the user interacts with the system, including references to backend components:

## 2. Step-by-Step User Journey

1. **Authenticate with Clerk**

   - The user logs in via Clerk, receiving a **JWT** token.
   - The token is included in each request’s `Authorization` header, which the backend verifies with `check_auth` in `dependencies.py`.
   - **Backend code** reference:
     - `dependencies.py`: sets up Clerk config.
     - `router_webhooks.py`: processes user creation/deletion webhooks from Clerk.

2. **Chat Interface with Suggestions**

   - On the frontend, the user sees strategy suggestions above the input box (e.g., “Create Bitcoin SMA cross strategy”).
   - The user can click a suggestion or type their own prompt.
   - **Backend code** reference:
     - `main.py` includes the `/chat` route generated by `langserve`.
     - Requests pass through `graph_main` (in `agents/main/graph_main.py`), which routes the user’s input to the right agent (e.g., `strategy` vs. `model`).

3. **User Requests Strategy Creation**

   - The user’s prompt is captured and sent to the backend.
   - The system dispatches to the `strategy` agent if it detects a strategy creation request (`router_instructions` in `agents/main/prompts/base.py`).
   - **Backend code** reference:
     - `graph_strategy.py`: Builds the final strategy object using the user’s prompt + optional feedback.
     - `strategy_instructions` in `agents/strategy/prompts/base.py` guides how the LLM should craft a Freqtrade strategy.

4. **Display Strategy Widget with “Deploy” & “Edit”**

   - The backend returns a structured JSON payload describing the newly created strategy.
   - The frontend shows it in an **interactive widget** with **Deploy** and **Edit** buttons.
   - **Backend code** reference:
     - `tools/strategy_output.py`: The LLM triggers a “tool call” to produce final strategy output.
     - The strategy data is also returned in the standard JSON form to the front-end.

5. **Edit Strategy Popup (Optional)**

   - If **Edit** is clicked, a popup displays the strategy’s properties for manual changes (timeframe, stop-loss, etc.).
   - The user can **Save** or **Cancel**.
   - The updated properties are likely stored in the front-end state or patched to the server if needed.

6. **Deploying the Strategy**

   - Clicking **Deploy** sends the strategy details to the backend’s **`/api/v1/strategies`** endpoint.
   - The backend:
     1. Validates the user token (`require_user` decorator in `decorators.py`).
     2. Creates a new `StrategiesORM` entry in the DB with the generated Python code (`service_strategies.py` → `add_strategy`).
   - The newly created strategy is displayed in the left-side panel.

7. **Post-Deployment Widget with “Backtest” & “Delete”**

   - After deployment, the widget updates to show **Backtest** and **Delete**.
   - The user can check performance or remove unwanted strategies.
   - **Backend code** reference:
     - `router_strategies.py`: `GET` to fetch user strategies, `DELETE` to remove strategies from the DB.

8. **Backtesting with Date Range Popup**

   - On **Backtest** click, the user picks a date range from a calendar popup.
   - The system starts a backtest job (the current reference code stubs out advanced features, but future expansions might trigger a Celery worker).
   - The widget is **disabled** with a loading spinner until results are ready.

9. **Spinner and Progress**
   - While backtesting runs, the **Backtest** button is replaced with a spinner.
   - Once completed, the system (or a separate job) returns performance metrics.
   - The user can refine or tweak the strategy if results are unsatisfactory.

## 3. Backend Architecture Flow

1. **Routers** (`app/routers/v1/`)

   - `router_strategies.py` manages CRUD for strategies (deploy, get list, delete).
   - `router_chats.py` handles storing chat messages and titles.
   - `router_webhooks.py` listens for Clerk user events.

2. **Service Layer** (`app/db/services/`)

   - Contains the business logic for operating on DB models.
   - E.g., `service_strategies.py` ensures the user is authorized to create or delete a strategy.

3. **Database Repositories** (`app/db/repositories/`)

   - Low-level access to the DB (create/edit/find/delete).
   - E.g., `repo_strategies.py` uses `StrategiesORM` to persist or retrieve strategies.

4. **Agents & StateGraph** (`app/agents/`)

   - `graph_main.py` routes user messages to the correct sub-agent.
   - `graph_strategy.py` constructs new strategies with structured outputs and can incorporate user feedback.

5. **Migration & Schema** (`app/db/migrations/`)
   - **Alembic** scripts for versioning and altering the DB schema.
   - Example: `48ce389f887d_add_strategies.py` creates the `strategies` table.

## 4. Error Handling & Alternate Paths

- **Authentication Failure**: If the user’s JWT is invalid, the system returns a `401 Unauthorized` via the `@require_user` decorator.
- **Edit Failure**: Attempting to edit a strategy that doesn’t belong to the user triggers a `403 Forbidden`.
- **LLM Timeout or Error**: If the LLM cannot generate code, an error message is returned to the user.
- **Backtest Error**: If the backtest fails or times out, the UI surfaces a meaningful message with steps to retry.

## 5. Conclusion

GenTrade’s flow provides a streamlined path from idea to live algorithmic trading. By combining:

- A robust **FastAPI** backend
- **LLM-based** strategy generation
- **Clerk** authentication
- A persistent, versioned **PostgreSQL** database

Users can design and iterate on trading strategies with minimal fuss. As the codebase evolves, the modular structure (agents, routers, repositories) ensures maintainability and scalability for future features such as automated forward-testing or advanced analytics dashboards.

---

**These updated documents provide a clearer picture of how your backend code, database migrations, and LLM-based logic tie in with the end-user workflows.** You can continue refining them to match your project’s specific objectives and development roadmap.
